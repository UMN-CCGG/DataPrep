# Load modules
import glob
import os
import subprocess
import pdb
import shutil

# Get the date
from datetime import datetime
i = datetime.now()
TIME = i.strftime('%Y-%m-%d')

# Specify config file
configfile: "workflow/config.yml"

if config['singularity']['use_singularity'] == 'true' and config['singularity']['image'] != "none":
    CMD_PREFIX = f"singularity exec {config['singularity']['image']} "
    CODE = config['singularity']['code']
else:
    CMD_PREFIX = config['cmd_prefix']
    CODE = config['dir']['code']

# Parse config.yml file
OUT = config['dir']['out']
QUERY = config['query']
BCFTOOLS = config['bcftools']['executable']

# Make subdirectories
if not os.path.exists("RefAnnotationData"): os.mkdir("RefAnnotationData")
if not os.path.exists("OandE"): os.mkdir("OandE")
for datset in QUERY.keys():
    if not os.path.exists(datset): os.mkdir(datset)

REFASTA = config['reference']['refFasta']
REFVCF = config['reference']['refVCF']

if config['updates']['FixRef'] == "true":
    if config['download_reference'] == 'true':
        REFASTA = "../RefAnnotationData/human_g1k_v37.fasta.gz"
        REFVCF = "../RefAnnotationData/All_20170710.vcf.gz"
    else:
        assert (REFASTA != "none" and REFVCF != "none"), "Must provide a reference fasta and VCF in workflow/config.yml file"
        assert os.path.exists(config['reference']['refFasta']), f"Did not find reference fasta: {config['reference']['refFasta']}"
        assert os.path.exists(config['reference']['refVCF']), f"Did not find reference VCF: {config['reference']['refVCF']}"

if config['local_run'] == 'true':
    localrules: all, update_alleles_IDs, FixRef, QCcombine_query
else:
    localrules: all


rule all:
    input:
        expand("{rawdata}/{rawdata}_alleles_IDs.bed", rawdata=QUERY.keys()),
        expand("{rawdata}/{rawdata}-FixRef.bed", rawdata=QUERY.keys()),
        expand("{rawdata}/{rawdata}-QC.bed", rawdata=QUERY.keys()),
        "workflow/done.txt"

rule clean:
    params: "{wildcards.rawdata}"
    shell:
        "rm RefAnnotationData/*; rm -r {wildcards.rawdata}/*"

rule update_alleles_IDs:
    input: QUERY
    output: "{rawdata}/{rawdata}_alleles_IDs.bed"
    params:
        in_pre = lambda wildcards: QUERY[wildcards.rawdata],
        prefix = "{rawdata}/{rawdata}",
        exec = f"{CMD_PREFIX} plink",
        alleles = config['updates']['allele_key'],
        ids = config['updates']['ID_key'],
        chrom_ids = config['updates']['chrom_key']
    run:
        # TODO: add assertions? necessary?
        if config['updates']['ID_key'] != "none":
            if config['updates']['allele_key'] != "none":
                if config['updates']['chrom_key'] != "none":
                    shell(f"{{params.exec}} --bfile {{params.in_pre}} --update-chr {{params.chrom_ids}} --make-bed --out {{params.prefix}}.chrom ; {{params.exec}} --bfile {{params.in_pre}}.chrom --update-alleles {{params.alleles}} --make-bed --out {{params.prefix}}_alleles; {{params.exec}} --bfile {{params.prefix}}_alleles --update-name {{params.ids}} --make-bed --out {{params.prefix}}_alleles_IDs")
                else:
                    shell(f"{{params.exec}} --bfile {{params.in_pre}} --update-alleles {{params.alleles}} --make-bed --out {{params.prefix}}_alleles; {{params.exec}} --bfile {{params.prefix}}_alleles --update-name {{params.ids}} --make-bed --out {{params.prefix}}_alleles_IDs")
            elif config['updates']['chrom_key'] != "none":
                shell(f"{{params.exec}} --bfile {{params.in_pre}} --update-chr {{params.chrom_ids}} --make-bed --out {{params.prefix}}.chrom; {{params.exec}} --bfile {{params.prefix}}.chrom --update-name {{params.ids}} --make-bed --out {{params.prefix}}_alleles_IDs")
            else:
                shell(f"{{params.exec}} --bfile {{params.in_pre}} --update-name {{params.ids}} --make-bed --out {{params.prefix}}_alleles_IDs")
        else:
            if config['updates']['allele_key'] != "none":
                if config['updates']['chrom_key'] != "none":
                    shell(f"{{params.exec}} --bfile {{params.in_pre}} --update-chr {{params.chrom_ids}} --make-bed --out {{params.prefix}}.chrom; {{params.exec}} --bfile {{params.prefix}}.chrom --update-alleles {{params.alleles}} --make-bed --out {{params.prefix}}_alleles")
                else:
                    shell(f"{{params.exec}} --bfile {{params.in_pre}} --update-alleles {{params.alleles}} --make-bed --out {{params.prefix}}_alleles_IDs")
            elif config['updates']['chrom_key'] != "none":
                shell(f"{{params.exec}} --bfile {{params.in_pre}} --update-chr {{params.chrom_ids}} --make-bed --out {{params.prefix}}_alleles_IDs")
            else:
                shell(f"{{params.exec}} --bfile {{params.in_pre}} --make-bed --out {{params.prefix}}_alleles_IDs")

rule FixRef:
    input: "{rawdata}/{rawdata}_alleles_IDs.bed",
    output: "{rawdata}/{rawdata}-FixRef.bed"
    params:
        prefix = "{rawdata}/{rawdata}",
        chr_key = config['updates']['chrom_key']
    run:
        if config['updates']['FixRef'] == "true":
            if config['download_reference'] == 'true':
                    shell(f"sh {CODE}/DownloadRefs.sh; sh {CODE}/FixRef.sh {{wildcards.rawdata}}_alleles_IDs {{wildcards.rawdata}}/ {{wildcards.rawdata}}-FixRef {{params.chr_key}} {REFASTA} {REFVCF} t t t t")
        else:
            shell(f"{CMD_PREFIX} plink --bfile {{params.prefix}}_alleles_IDs --make-bed --out {{params.prefix}}-FixRef")

rule QCcombine_query:
    input: "{rawdata}/{rawdata}-FixRef.bed"
    output: "{rawdata}/{rawdata}-QC.bed"
    params:
        pre = "{rawdata}/{rawdata}",
        tvm1 = config['QC']['vm1'], tgm = config['QC']['gm'], tvm2 = config['QC']['vm2'],
        hwe = config['QC']['hwe'], maf = config['QC']['maf'], mbs = config['QC']['mbs']
    run:
        if config['perform_QC'] == 'true':
            shell(f"{CMD_PREFIX} python {CODE}/QC.py -i {{params.pre}}-FixRef -d {{wildcards.rawdata}} -o {{wildcards.rawdata}}-QC -p plink -tvm1 {{params.tvm1}} -tgm {{params.tgm}} -tvm2 {{params.tvm2}} -hwe {{params.hwe}} -mbs {{params.mbs}} -maf {{params.maf}}")
        else:
            shell(f"{CMD_PREFIX} plink --bfile {{params.pre}}-FixRef --make-bed --out {{params.pre}}-QC")

rule merge_inputs:
    input: expand("{rawdata}/{rawdata}-QC.bed", rawdata=QUERY.keys())
    output: "workflow/done.txt"
    params:
        input_list = ",".join([f"{x}/{x}-QC" for x in QUERY.keys()])
    run:
        if config['merge'] == 'true':
            shell(f"{CMD_PREFIX} python {CODE}/mergeInputs.py -i {{params.input_list}} -d {os.getcwd()} -o {OUT} -p plink; touch workflow/done.txt")
        else:
            shell("touch workflow/done.txt")


# rule mis_impute_prep:
#     input: "{rawdata}/{rawdata}-QC.bed"
#     output: "workflow/done.txt"
#     run:
#         if config['impute_prep'] == 'true':
#             shell(f"sh ")

#rule remove_intermediates:
    #input:
